{"name":"Observed","tagline":"ES6 Object.observe with nested object support","body":"\r\n[![Build Status](https://travis-ci.org/aheckmann/observed.svg?branch=master)](https://travis-ci.org/aheckmann/observed)\r\n\r\n## What?\r\n\r\nDo you dream of observing a plain javascript object for changes and reacting to it later? Now you can.\r\n\r\nAvailable in **Node >= 0.11.13**, the standards compliant [Object.observe](http://wiki.ecmascript.org/doku.php?id=harmony:observe) treasure resides.\r\n\r\n`Object.observe` allows us to register a listener for any type of change to a given object.\r\n\r\n```js\r\nvar o = { name: 'harmony' };\r\nObject.observe(o, function (changes) {\r\n  console.log(changes);\r\n})\r\no.name = 'ES6!'\r\no.kind = 'observed';\r\n\r\n// logs..\r\n// [ { type: 'update',\r\n//     object: { name: 'ES6!', kind: 'observed' },\r\n//     name: 'name',\r\n//     oldValue: 'harmony' },\r\n//   { type: 'add',\r\n//     object: { name: 'ES6!', kind: 'observed' },\r\n//     name: 'kind' } ]\r\n```\r\n\r\nYou'll notice our callback received an array of all changes that occured. Cool.\r\nBut what about nested objects? Do they get automatically observed as well?\r\n\r\n```js\r\nvar o = { nested: { deeper: true }};\r\nObject.observe(o, function (changes) {\r\n  console.log(changes);\r\n})\r\no.nested.deeper = false\r\n// crickets ..\r\n```\r\n\r\nTurns out they don't. And that's what `observed` is for: watching object modifications without having to care about whether or not they have nested objects and arrays.\r\n\r\n## Usage\r\n\r\n`observed` returns an `EventEmitter` which you listen to for changes.\r\nThere are five classes of events, closely mirroring `Object.observe`\r\n\r\n- `add`\r\n- `update`\r\n- `delete`\r\n- `reconfigure`\r\n- `change` - fired when any of the above events are emitted\r\n\r\n```js\r\nvar O = require('observed')\r\nvar object = { name: {} }\r\nvar ee = O(object)\r\n\r\nee.on('add', console.log)\r\n\r\nobject.name.last = 'observed'\r\n\r\n// logs\r\n// { path: 'name.last',\r\n//   name: 'last',\r\n//   type: 'add',\r\n//   object: { last: 'observed' },\r\n//   value: 'observed',\r\n//   oldValue: undefined }\r\n```\r\n\r\nYou'll notice we now receive more information compared to `Object.observe`\r\n\r\n- `path`: full path to the property, including nesting\r\n- `name`: name of the path reported by `Object.observe`\r\n- `type`: name of the event reported by `Object.observe`\r\n- `object`: object reported from `Object.observe`\r\n- `value`: current value for the given `path`. same as `object[name]`\r\n- `oldValue`: previous value of the property as reported by `Object.observe`\r\n\r\nYou may also listen for changes to specific paths:\r\n\r\n```js\r\nvar O = require('observed')\r\nvar object = { name: { last: 'Heckmann', first: 'aaron' }}\r\nvar ee = O(object)\r\n\r\nee.on('update name.first', console.log)\r\n\r\nobject.name.first = 'Aaron'\r\n\r\n// logs\r\n// { path: 'name.first',\r\n//   name: 'first',\r\n//   type: 'update',\r\n//   object: { last: 'Heckmann', first: 'Aaron' },\r\n//   value: 'Aaron',\r\n//   oldValue: 'aaron' }\r\n```\r\n\r\n### deliverChanges()\r\n\r\nThere are occasions where we want to immediately force all pending changes to\r\nemit instead of waiting for the next turn of the event loop. `observed` has\r\nus covered here too. Just call its `deliverChanges()` method and all pending\r\nchanges will emit.\r\n\r\n```js\r\nvar O = require('observed');\r\nvar obj = { movie: { title: 'Godzilla' }};\r\nvar ee = O(obj);\r\n\r\nvar emitted = false;\r\nee.on('change', function(){ emitted = true });\r\n\r\nobj.movie.year = 2014;\r\nassert.equal(false, emitted);\r\n\r\nee.deliverChanges();\r\nassert.equal(true, emitted);\r\n// :)\r\n```\r\n\r\n## Use cases\r\n\r\n1. passing object changes down to a browser in realtime using something like [primus](https://github.com/primus/primus).\r\n2. fanning out object changes across multiple nodes using something like [axon](https://github.com/visionmedia/axon).\r\n3. buffering changes and pass them off to your database of choice in one `save` action.\r\n\r\n## Features\r\n\r\n1. Object tracking: Using ES6 `Object.observe` we provide support for rich object tracking without manual getters/setters.\r\n2. Unobtrusive: Your object remains untouched and you may work with it as a plain js object.\r\n3. Events: Receive an `EventEmitter` back which emits the following events:\r\n\r\n- `add`\r\n- `update`\r\n- `delete`\r\n- `reconfigure`\r\n- `change` - fired when any of the above events are emitted\r\n\r\n## Node version requirements\r\n\r\n`Object.observe` is available by default in Node >= `0.11.13`.\r\n\r\n```\r\n> node yourProgram.js\r\n```\r\n\r\nIf you are running Node `>= 0.11.0 < 0.11.13` you must run Node using the `--harmony` flag\r\nand use a `0.0.n` version of this module.\r\n\r\n```\r\n> npm install observed@0.0.3\r\n> node --harmony yourProgram.js\r\n```\r\n\r\n## Tests\r\n\r\nRun em with `npm test`\r\n\r\n## License\r\n\r\n[MIT](https://github.com/aheckmann/observed/blob/master/LICENSE)\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}