{"name":"Observed","tagline":"ES6 Object.observe with nested object support","body":"## what?\r\n\r\nDo you dream of observing a plain javascript object for changes and reacting to it later? Now you can.\r\n\r\nHiding being the `--harmony` flag of Node 0.11, the [Object.observe](http://wiki.ecmascript.org/doku.php?id=harmony:observe) gem resides.\r\n\r\n`Object.observe` allows us to register a listener for any type of change to a given object.\r\n\r\n```js\r\n// node --harmony\r\n\r\nvar o = { name: 'harmony' };\r\nObject.observe(o, function (changes) {\r\n  console.log(changes);\r\n})\r\no.name = 'ES6!'\r\no.kind = 'observed';\r\n\r\n// logs..\r\n// [ { type: 'updated',\r\n//     object: { name: 'ES6!', kind: 'observed' },\r\n//     name: 'name',\r\n//     oldValue: 'harmony' },\r\n//   { type: 'new',\r\n//     object: { name: 'ES6!', kind: 'observed' },\r\n//     name: 'kind' } ]\r\n```\r\n\r\nYou'll notice our callback received an array of all changes that occured. Cool.\r\nBut what about nested objects? Do they get automatically observed as well?\r\n\r\n```js\r\n// node --harmony\r\n\r\nvar o = { nested: { deeper: true }};\r\nObject.observe(o, function (changes) {\r\n  console.log(changes);\r\n})\r\no.nested.deeper = false\r\n// crickets ..\r\n```\r\n\r\nTurns out they don't. That's what `observed` is for: watching objects for changes without having to care about whether or not they have nested objects and arrays.\r\n\r\n## usage\r\n\r\n`observed` returns an `EventEmitter` which you listen to for changes.\r\nThere are four classes of events, mirroring `Object.observe`\r\n\r\n- `new`\r\n- `updated`\r\n- `deleted`\r\n- `reconfigured`\r\n\r\n```js\r\nvar O = require('observed')\r\nvar object = { name: {} }\r\nvar ee = O(object)\r\n\r\nee.on('new', console.log)\r\n\r\nobject.name.last = 'observed'\r\n\r\n// logs\r\n// { path: 'name.last',\r\n//   name: 'last',\r\n//   type: 'new',\r\n//   object: { last: 'observed' },\r\n//   value: 'observed',\r\n//   oldValue: undefined }\r\n```\r\n\r\nYou'll notice we now receive more information compared to `Object.observe`\r\n\r\n- `path`: full path to the property, including nesting\r\n- `name`: name of the path reported by `Object.observe`\r\n- `type`: name of the event reported by `Object.observe`\r\n- `object`: object reported from `Object.observe`\r\n- `value`: current value for the given `path`. same as `object[name]`\r\n- `oldValue`: previous value of the property as reported by `Object.observe`\r\n\r\nYou may also listen for changes to specific paths:\r\n\r\n```js\r\nvar O = require('observed')\r\nvar object = { name: { last: 'Heckmann', first: 'aaron' }}\r\nvar ee = O(object)\r\n\r\nee.on('updated name.first', console.log)\r\n\r\nobject.name.first = 'Aaron'\r\n\r\n// logs\r\n// { path: 'name.first',\r\n//   name: 'first',\r\n//   type: 'updated',\r\n//   object: { last: 'Heckmann', first: 'Aaron' },\r\n//   value: 'Aaron',\r\n//   oldValue: 'aaron' }\r\n```\r\n\r\n## use cases\r\n\r\n1. passing object changes down to a browser in realtime using something like [primus](https://github.com/primus/primus).\r\n2. fanning out object changes across multiple nodes using something like [axon](https://github.com/visionmedia/axon).\r\n3. buffering changes and pass them off to your database of choice in one `save` action.\r\n\r\n## features\r\n\r\n1. Object tracking: Using ES6 `Object.observe` we provide support for rich object tracking without manual getters/setters.\r\n2. Unobtrusive: Your object remains untouched and you may work with it as a plain js object.\r\n3. Events: Receive an `EventEmitter` back which emits the following events:\r\n\r\n- `added`\r\n- `removed`\r\n- `changed`\r\n- `reconfigured`\r\n\r\n## harmonious\r\n\r\nYou must run node using the `--harmony` flag to use this module.\r\n\r\n```\r\n> node --harmony yourProgram.js\r\n```\r\n\r\n## tests\r\n\r\nRun em with `npm test`\r\n\r\n## license\r\n\r\n[MIT](https://github.com/aheckmann/observed/blob/master/LICENSE)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}